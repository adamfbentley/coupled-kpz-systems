# PHYS345 Numerical Project: Simulation of Thin Film Growth
#
# A completely rewritten script to ensure correctness, simplicity, and robust plotting.
# This version is designed to be clear and demonstrate the physical evolution correctly.

import numpy as np
import matplotlib.pyplot as plt

# --- IMPORTANT: This forces plots to open in a separate, interactive window. ---
# This bypasses issues with Spyder's default "Plots" pane and is more reliable.
# This line should be at the very top of your script.
import matplotlib
matplotlib.use('Qt5Agg')


### PART 1: SETUP AND SIMULATION ###

print("--- Part 1: Setting up Simulation ---")

# All parameters are defined in one place for easy modification
PARAMS = {
    'grid_size': 256,        # The N x N size of the simulation grid
    'total_time': 100.0,     # Run for 100s to capture all snapshots
    'time_step': 0.01,       # The size of each discrete time step (dt)
    'dx': 1.0,               # The spatial step size
    'nu': 1.0,               # ν: The surface tension / smoothing term
    'lambda': 4.0,           # λ: The non-linear growth term (roughening)
    'noise_strength': 0.5,   # D: The magnitude of the random noise (roughening)
}

# Start with a PERFECTLY FLAT surface. Any roughness will be generated by the simulation.
h = np.zeros((PARAMS['grid_size'], PARAMS['grid_size']))

# Store the initial state for plotting later.
# np.copy() is vital to prevent the simulation from changing this snapshot.
h_at_t0 = np.copy(h)

# Prepare variables to hold the other snapshots
h_at_t50 = None

# Calculate which simulation step corresponds to t=50
num_steps = int(PARAMS['total_time'] / PARAMS['time_step'])
step_for_t50 = int(50.0 / PARAMS['time_step'])

print(f"Starting simulation for {num_steps} steps...")

# The main simulation loop
for i in range(num_steps):
    # Calculate neighbors using np.roll for periodic boundaries
    h_plus_x = np.roll(h, -1, axis=1)
    h_minus_x = np.roll(h, 1, axis=1)
    h_plus_y = np.roll(h, -1, axis=0)
    h_minus_y = np.roll(h, 1, axis=0)
    
    # Term 1: The Laplacian (∇²h) for smoothing (surface tension).
    laplacian_h = (h_plus_x + h_minus_x + h_plus_y + h_minus_y - 4 * h) / (PARAMS['dx']**2)

    # Term 2: The non-linear gradient-squared (|∇h|²) for roughening.
    dh_dx = (h_plus_x - h_minus_x) / (2 * PARAMS['dx'])
    dh_dy = (h_plus_y - h_minus_y) / (2 * PARAMS['dx'])
    grad_h_sq = dh_dx**2 + dh_dy**2

    # Term 3: The stochastic noise (η) for roughening.
    noise = np.random.randn(PARAMS['grid_size'], PARAMS['grid_size']) * np.sqrt(2 * PARAMS['noise_strength'] * PARAMS['time_step']) / PARAMS['dx']
    
    # The full KPZ equation. The signs are set for a roughening process.
    dh_dt = (PARAMS['nu'] * laplacian_h + 0.5 * PARAMS['lambda'] * grad_h_sq + noise)
    
    # Update the surface height using the forward Euler method
    h += dh_dt * PARAMS['time_step']

    # --- SANITY CHECK: Print the standard deviation of the height ---
    # If this number increases, the simulation IS working and the surface is getting rougher.
    if (i + 1) % 1000 == 0: # Print every 1000 steps
        print(f"Step {i+1}/{num_steps}, Surface Roughness (Std Dev): {np.std(h):.4f}")

    # Check if we have reached t=50 and save a snapshot
    if i == step_for_t50 - 1:
        h_at_t50 = np.copy(h)

print("Simulation finished.")


### PART 2: VISUALIZE THE EVOLUTION ###

print("\n--- Part 2: Generating Time Evolution Plot ---")

# Create a figure with 3 vertically stacked subplots
fig, axes = plt.subplots(3, 1, figsize=(10, 15), sharex=True)
fig.suptitle('Evolution of Surface Profile Over Time', fontsize=16)

# Get the cross-section data for each snapshot
profile_t0 = h_at_t0[PARAMS['grid_size'] // 2, :]
profile_t50 = h_at_t50[PARAMS['grid_size'] // 2, :]
profile_t100 = h[PARAMS['grid_size'] // 2, :] # The final state of 'h'

# Intelligently set the Y-axis limits to fit all data visibly
min_h = min(profile_t0.min(), profile_t50.min(), profile_t100.min())
max_h = max(profile_t0.max(), profile_t50.max(), profile_t100.max())
y_buffer = (max_h - min_h) * 0.1 # Add 10% buffer for aesthetics
y_lims = [min_h - y_buffer, max_h + y_buffer]

# Plot t=0
axes[0].plot(np.arange(PARAMS['grid_size']), profile_t0, color='green')
axes[0].set_title('Initial State at t = 0')
axes[0].set_ylabel('Height')
axes[0].set_ylim(y_lims)
axes[0].grid(True, linestyle='--', alpha=0.6)

# Plot t=50
axes[1].plot(np.arange(PARAMS['grid_size']), profile_t50, color='orange')
axes[1].set_title('State at t = 50')
axes[1].set_ylabel('Height')
axes[1].set_ylim(y_lims)
axes[1].grid(True, linestyle='--', alpha=0.6)

# Plot t=100
axes[2].plot(np.arange(PARAMS['grid_size']), profile_t100, color='darkblue')
axes[2].set_title(f'Final State at t = {PARAMS["total_time"]}')
axes[2].set_xlabel('Position (x)')
axes[2].set_ylabel('Height')
axes[2].set_ylim(y_lims)
axes[2].grid(True, linestyle='--', alpha=0.6)

plt.tight_layout(rect=[0, 0, 1, 0.96])
plt.show()


### PART 3: ANALYZE FINAL ROUGHNESS (PSD) ###

print("\n--- Part 3: Analyzing Roughness of Final Surface ---")

h_k = np.fft.fft2(h)
psd_2d = np.abs(h_k)**2
q_freq = np.fft.fftfreq(PARAMS['grid_size'], d=PARAMS['dx'])
q_x, q_y = np.meshgrid(q_freq, q_freq)
q_radial = np.sqrt(q_x**2 + q_y**2)

bin_width = q_freq.max() / (PARAMS['grid_size'] / 2)
q_bins = np.arange(0, q_radial.max(), bin_width)
psd_1d = np.zeros(len(q_bins) - 1)
q_vals = 0.5 * (q_bins[1:] + q_bins[:-1])

for i in range(len(q_bins) - 1):
    mask = (q_radial >= q_bins[i]) & (q_radial < q_bins[i+1])
    if np.any(mask):
        psd_1d[i] = psd_2d[mask].mean()

plt.figure(figsize=(8, 6))
plt.loglog(q_vals[1:], psd_1d[1:], 'o', markersize=5, label=f'PSD at t={PARAMS["total_time"]}')
q_fit = q_vals[q_vals > 2]
if len(q_fit) > 0:
    fit = q_fit**(-4) * psd_1d[q_vals > 2][0] / q_fit[0]**(-4)
    plt.plot(q_fit, fit, 'r--', label=r'Reference line ($q^{-4}$)')

plt.xlabel('Spatial Frequency, q')
plt.ylabel('Power Spectral Density, PSD(q)')
plt.title('Roughness Analysis of Final Surface')
plt.legend()
plt.grid(True, which="both", ls="--", alpha=0.5)
plt.show()

print("\nScript finished.")