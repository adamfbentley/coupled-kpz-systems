# -*- coding: utf-8 -*-
"""
Created on Wed Aug 13 12:59:50 2025

@author: adamf
"""

# PHYS345 Numerical Project: 1D Thin-Film Growth Simulation

# This code simulates surface growth and visualizes its evolution over time.

import numpy as np
import matplotlib.pyplot as plt

### PART 1: SETUP AND SIMULATION ###

print("--- Part 1: Setting up Simulation ---")

# All parameters are defined in one place
PARAMS = {
    'grid_size': 512,        # L/dx: The number of points on our 1D surface
    'total_time': 100.0,     # The total physical time to simulate
    'time_step': 0.01,       # dt: The size of each discrete time step
    'dx': 1.0,               # The spatial step size
    'nu': 1.0,               # ν: The surface tension / smoothing coefficient
    'lambda': 1.0,           # λ: The non-linear growth coefficient (the KPZ term)
    'noise_strength': 1.0,   # D: The magnitude of the random noise
}

# --- Initial Conditions ---
# perfectly flat surface to clearly see the growth generated by the simulation.
h = np.zeros(PARAMS['grid_size'])

# --- Snapshot Setup ---
# We store a copy of the initial state for our t=0 plot.
# np.copy() is crucial so this variable isn't changed during the simulation.
h_at_t0 = np.copy(h)
# This variable will hold our surface data at t=50.
h_at_t50 = None

# --- Simulation Time Setup ---
# Calculate the total number of steps and the step number for our snapshot.
num_steps = int(PARAMS['total_time'] / PARAMS['time_step'])
step_for_t50 = int(50.0 / PARAMS['time_step'])

print(f"Starting simulation for {num_steps} steps...")

# The main simulation loop, evolving the surface 'h' over time.
for i in range(num_steps):
    # As suggested in the brief, we use np.roll to get neighbor values efficiently.
    # This is much faster than a for loop.
    h_plus_1 = np.roll(h, -1)  # h(x_{i+1})
    h_minus_1 = np.roll(h, 1)   # h(x_{i-1})
    
    # --- Physics Calculations ---
    # Each term from the growth equation is calculated separately for clarity.
    
    # Term 1: The Laplacian (smoothing), using the finite difference formula
    # from the brief: (h_{i+1} - 2h_i + h_{i-1}) / dx^2
    laplacian_h = (h_plus_1 + h_minus_1 - 2 * h) / (PARAMS['dx']**2)

    # Term 2: The non-linear KPZ term (roughening)
    grad_h = (h_plus_1 - h_minus_1) / (2 * PARAMS['dx'])
    grad_h_sq = grad_h**2
    
    # Term 3: The stochastic noise term (η)
    # This adds a small random "kick" to each point at each time step.
    noise = np.random.randn(PARAMS['grid_size']) * np.sqrt(2 * PARAMS['noise_strength'] * PARAMS['time_step']) / PARAMS['dx']

    # --- Update Step ---
    # We combine the terms to get the change in height, Δh, as per the brief.
    # This is the Euler method: h_new = h_old + Δt * (change rate)
    dh_dt = (PARAMS['nu'] * laplacian_h + 0.5 * PARAMS['lambda'] * grad_h_sq + noise)
    h += dh_dt * PARAMS['time_step']

    # Check if the current step is our snapshot point for t=50.
    if i == step_for_t50 - 1:
        print(f"Taking snapshot at step {i+1} (t=50s)...")
        h_at_t50 = np.copy(h)

print("Simulation finished.")


### PART 2: VISUALIZE THE EVOLUTION ###

print("\n--- Part 2: Generating Time Evolution Plot ---")

# Create a figure with 3 vertically stacked subplots.
# `sharex=True` links the x-axes for easier comparison.
fig, axes = plt.subplots(3, 1, figsize=(10, 15), sharex=True)
fig.suptitle('Evolution of Surface Profile Over Time', fontsize=16)

# Get the profile data for each snapshot
profile_t0 = h_at_t0
profile_t50 = h_at_t50
profile_t100 = h # The final state of 'h'

# Intelligently set the Y-axis limits to fit all data visibly
min_h = min(profile_t0.min(), profile_t50.min(), profile_t100.min())
max_h = max(profile_t0.max(), profile_t50.max(), profile_t100.max())
y_buffer = (max_h - min_h) * 0.1 # Add 10% buffer
y_lims = [min_h - y_buffer, max_h + y_buffer]

# Plot t=0
axes[0].plot(np.arange(PARAMS['grid_size']), profile_t0, color='green')
axes[0].set_title('Initial State at t = 0')
axes[0].set_ylabel('Height')
axes[0].set_ylim(y_lims)
axes[0].grid(True, linestyle='--', alpha=0.6)

# Plot t=50
axes[1].plot(np.arange(PARAMS['grid_size']), profile_t50, color='orange')
axes[1].set_title('State at t = 50')
axes[1].set_ylabel('Height')
axes[1].set_ylim(y_lims)
axes[1].grid(True, linestyle='--', alpha=0.6)

# Plot t=100
axes[2].plot(np.arange(PARAMS['grid_size']), profile_t100, color='darkblue')
axes[2].set_title(f'Final State at t = {PARAMS["total_time"]}')
axes[2].set_xlabel('Position (x)')
axes[2].set_ylabel('Height')
axes[2].set_ylim(y_lims)
axes[2].grid(True, linestyle='--', alpha=0.6)

plt.tight_layout(rect=[0, 0, 1, 0.96]) # Adjust plot spacing
plt.show()


### PART 3: ANALYZE FINAL ROUGHNESS (PSD) ###

print("\n--- Part 3: Analyzing Roughness of Final Surface ---")

# This fulfills the requirement to "use the fast-Fourier-transform...
# and plot the power spectral density".

# Remove the mean height before FFT for a cleaner spectrum at zero frequency
h_final_detrended = h - np.mean(h)

# Calculate the FFT and then the Power Spectrum
fft_h = np.fft.fft(h_final_detrended)
psd = np.abs(fft_h)**2 / PARAMS['grid_size'] # Normalize by system size

# Get the corresponding spatial frequencies (q)
# We only need the first half (positive frequencies) for the plot
freq = np.fft.fftfreq(PARAMS['grid_size'], d=PARAMS['dx'])
positive_freq_mask = freq > 0
freq = freq[positive_freq_mask]
psd = psd[positive_freq_mask]

# Plot the PSD on a log-log scale to identify power-law behavior
plt.figure(figsize=(8, 6))
plt.loglog(freq, psd, 'o', markersize=4, label=f'PSD at t={PARAMS["total_time"]}')

# Add a reference line to show what a power-law trend looks like
ref_slope = 10 * freq**(-2) # A simple q^-2 line for visual comparison
plt.loglog(freq, ref_slope, '--', color='gray', label='Reference Slope ($q^{-2}$)')

plt.xlabel('Spatial Frequency, q')
plt.ylabel('Power Spectral Density, PSD')
plt.title('Roughness Analysis of Final Surface')
plt.legend()
plt.grid(True, which="both", ls="--", alpha=0.5)
plt.show()

print("\nScript finished.")